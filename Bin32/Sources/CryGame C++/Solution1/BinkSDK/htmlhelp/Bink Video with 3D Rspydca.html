<!-- This page was created with the RAD auto-doc generator. -->
<!doctype html public "-//w3c//dtd html 3.2 final//en">
<html>
<head>
<title>Bink Video with 3D Rendering</title>
<meta http-equiv="content-type" content="text/html; charset=iso8859-1">
<meta name="ms.locale" content="en-us">
<meta name="description" content="">
<meta name="ms-hkwd" content="Bink Video with 3D Rendering">
<link rel="stylesheet" title="default" href="reference.css" type="text/css" media="screen">
</head>
<body topmargin="0">
<table cellspacing=0 cellpadding=0 class=bar width=100% height=25>
<tr class=bar>
<td class=bar>
<i>&nbsp;<a href="index.html" class=trn>Bink SDK 1.9c</a></i>
</td>
</tr>
</table>
<h1>Bink Video with 3D Rendering</h1>
<h4>Discussion</h4>
<p>Bink's design makes it very easy to integrate into a 3D rendering pipeline. In fact, depending on the platform, Bink gives you lots of ways to draw video inside your 3D game, all of which have different pros and cons. Let's discuss the options. </p><p>1) You can use <a href="BinkCopyToBuffer.html">BinkCopyToBuffer</a> to <b>blast directly to the back buffer</b> before you flip or swap. This is the most compatible and fastest way to play back your video. However, this option doesn't allow your video to be stretched by the hardware. Depending on the resolution of your movies and game, this may or may not be a problem. </p><p><b>PROS:</b> fast, widely compatible. <b>CONS:</b> video can't be stretched, color conversion is done is software. </p><p>2) You can try <b>blitting onto the primary 3D surface</b> (by using BinkBuffers, for example). In this option, you simply call the 2D blitting functions of the platform to blit onto the screen after you do the Present or SwapBuffers. The problem with this option is that many PC and Mac video cards don't support it correctly. It might work fine on your machine, but it could fail on older video cards. So, we don't recommend this option unless you know it will always work (like on a console or embedded system). </p><p><b>PROS:</b> none, there are better solutions. <b>CONS:</b> it will fail - don't use this method (put another way - don't use the BinkBuffer API while the 3D system is running). </p><p>3) You can use the <b>fixed function 3D pipeline to render the frames through an RGB texture</b>. This is a good option, because the 3D hardware can stretch your video to fill the screen. We supply high-level example code that handles the textures and vertices to use this method for most platforms. The only downside to this option is the "texture swizzling" hit. </p><p>Texture swizzling is the re-ordering the video texture memory so that it can be accessed by the GPU more efficiently. Almost all 3D hardware swizzles the texels by default. The problem with swizzling is that it is usually performed on the host CPU (and slowly at that). For example, on a Pentium III and with a geForce II graphics card, playing back a 640x480 video uses 90% of the CPU time just for texture swizzling! This doesn't leave Bink with much CPU time. </p><p>Fortunately, as game companies played video through the 3D system more and more (usually with Bink), the video cards exposed a new hint in the 3D APIs called "dynamic textures" or "linear textures". This hint tells the 3D card to access the textures linearly instead of in swizzled format (even if this causes rasterization to run slightly slower). On that same P3/geForce II setup, using dynamic textures on D3D drops the CPU use from 90% to less than 1%! </p><p>However, there is still some hardware that doesn't support dynamic/linear textures (and even when they do, they could have old drivers installed that don't support the linear flags). So, you should always have a fallback when using 3D textures. </p><p>Most people just use the back buffer method as their fallback (which we recommend), but some ship smaller videos for slower machines. Smaller videos can be swizzled up to the video card faster (a 320x240 video will swizzle at least 4 times faster than a 640x480 video). </p><p>Note that swizzling on the consoles isn't too big of an issue because most of them support linear textures. </p><p><b>PROS:</b> hardware stretching, widely compatible, usually uses page flipping for smooth playback. <b>CONS:</b> may be too slow on PCs and Macs - make sure you have a fallback, standard 3D hardware reliability problems. </p><p>4) You can use <b>3D hardware pixel shaders/register combiners with several luminance (8-bit) textures</b> to convert the YUV data into RGB pixels directly at render time. On the 3D hardware that can do it (Windows, Playstation 3, GameCube, Wii, Xbox 360 and Xbox), this is the best option. It can stretch, uses the least memory, is super fast, and has the best quality. </p><p>This is such the right option on Windows, PS3, Wii, GameCube, Xbox and Xbox 360 that we provide a cross platform API to do this pixel shader blitting. See the <b>BinkTextures.h</b> file for details. </p><p><b>PROS:</b> very fast, highest quality, uses very little memory on consoles, usually uses page flipping for smooth playback. <b>CONS:</b> requires pixel shaders/register combiners on the video card (not a problem if your game uses pixel shaders, of course). </p><p>6) You can use <b>3D hardware with multi-pass rendering using several luminance (8-bit) textures</b> to convert the YUV data into RGB pixels directly at render time. On the 3D hardware that supports it (Sony PSP and Sony PS2), this is the best option. It can stretch, uses the least memory, is super fast, and has the best quality. </p><p>This is such the right option on Sony PSP and PS2 that we provide a cross platform API to do this 3D palette blitting. See the <b>BinkPaletteTextures.h</b> file for details. </p><p><b>PROS:</b> very fast, highest quality, uses very little memory on consoles, usually uses page flipping for smooth playback. <b>CONS:</b> slightly complicated to setup (although we supply an API to do it). </p><p>7) You can use an <b>overlay surface</b>. Overlays float above the 3D (and 2D) surfaces, so they don't affect your 3D rendering at all. The only problem here is compatibility. On most Windows video cards, overlays aren't reliable enough to use widely (especially while the 3D system is active). On the Xbox (where the overlay system is robust and ubiquitous), this is the easiest option (although pixel shaders will look better). </p><p><b>PROS:</b> very fastest option (color conversion and stretching done in hardware), no interference with your 3D system, good quality. <b>CONS:</b> really only reliable on Xbox or embedded systems. </p><p>So, what option should you use? Well, it depends on your platform. Here are our recommendations: </p><p><b>PCs (Windows, MacOS and GNU/Linux):</b> If your game uses pixel shaders, use the pixel shader method. Otherwise, use the back buffer method by default. If your game can run at higher resolution than your videos, allow the user to select the 3D texture method to stretch the video to full screen. Remember that since many machines won't be able to swizzle the data fast enough, always default to using the back buffer method! We've had customers fail to do this and they always regretted it later. </p><p><b>Microsoft Xbox 360:</b> Use the pixel shader method. It's super fast, has great quality, and uses the least amount of memory of the other options. </p><p><b>Microsoft Xbox:</b> For best quality, speed, and memory hit, use the pixel shader method. It's super fast, has great quality, and uses the least amount of memory of the other options. For simplicity, you can use the overlay method - it will avoid messing with the pixel pipeline, but will take more memory and is slower. </p><p><b>Sony Playstation 3:</b> Use the pixel shader method. It's super fast, has great quality, and uses the least amount of memory of the other options. </p><p><b>Sony PSP:</b> Use the 3D hardware multi-pass method. It's super fast, has great quality, and uses the least amount of memory of the other options. </p><p><b>Sony Playstation 2:</b> Use the 3D hardware multi-pass method. It's super fast, has great quality, and uses the least amount of memory of the other options. </p><p><b>Nintendo Wii:</b> Use the back buffer method - the Wii backbuffer is YUV (the Bink native format), so we simply have to copy the bytes over with no color conversion. If you want to use the 3D texture method, use the multi-pass method to avoid software color conversions in software. </p><p><b>Nintendo GameCube:</b> Use the back buffer method - the GameCube backbuffer is YUV (the Bink native format), so we simply have to copy the bytes over with no color conversion. If you want to use the 3D texture method, use the multi-pass method to avoid software color conversions in software. </p><p><br> <b>IMPORTANT NOTE!</> Remember that when playing <i>non</i>-alpha plane videos through the 3D system, you must turn off the alpha blending renderstate! Bink doesn't set the alpha value on non-alpha pixel formats (like <a href="BINK_COPY_FLAGS.html#BINKSURFACE32">BINKSURFACE32</a>) because it would slow blitting down! If you try to play non-alpha video and the screen is black, then you probably have the alpha render state accidentally turned on. </p>
<p><a href="Audio Tracks in Bink.html">Next Topic (Audio Tracks in Bink)</a>  </p><p><a href="Colorspace - RGB vs. YUV.html">Previous Topic (Colorspace - RGB vs. YUV)</a>  </p><p>
<br>
<b>Group:</b>
<a href="Bink Overview.html">Bink Overview</a><br>
<b>Related Sections:</b>
<a href="Direct3D.html">Direct3D</a>, <a href="OpenGL.html">OpenGL</a><br>
<b>Related Functions:</b>
<a href="BinkCopyToBuffer.html">BinkCopyToBuffer</a><br>
<b>Related Basic Types:</b>
<a href="BINK_COPY_FLAGS.html">BINK_COPY_FLAGS</a></p>
<p align=center>
<a href="mailto:Bink3@radgametools.com">For technical support, e-mail Bink3@radgametools.com</a>
<br>
<a href="http://www.radgametools.com/bnkmain.htm?from=help1.9c">&#169; Copyright 1994-2008 RAD Game Tools, Inc. All Rights Reserved.</a>
</p>
<br>
</body>
</html>
